#include "OpenBox.h"
#include "../Camera.h"


OpenBox::OpenBox(glm::vec3 a_pos, glm::vec3 a_scale, float a_wallOcc, float a_wallReverb, float a_reverbRadius, float a_reverbOuterReverb, const char* a_soundFilePath) : 
	Node(a_pos, a_scale, glm::quat(), nullptr), m_wallOcclusion(a_wallOcc), m_wallReverb(a_wallReverb), m_reverbInnerRadius(a_reverbRadius), m_reverbOuterRadius(a_reverbOuterReverb), m_audioFilePath(a_soundFilePath)
{
	m_position = a_pos;
	m_scale = a_scale;
}


OpenBox::~OpenBox()
{
}

void OpenBox::Init(FMOD::System* a_FMsystem)
{
	m_walls[0] = new Rect(std::string("Left Wall"),	glm::vec3(-m_reverbOuterRadius, 0, 0), glm::vec3(m_scale.x, m_scale.y, m_scale.z), m_rotation, m_cubeVertShader, m_cubeFragShader, m_wallOcclusion, m_wallReverb, this); // Left
	m_walls[1] = new Rect(std::string("Right Wall"), glm::vec3(m_reverbOuterRadius, 0, 0),  glm::vec3(m_scale.x, m_scale.y, m_scale.z), m_rotation, m_cubeVertShader, m_cubeFragShader, m_wallOcclusion, m_wallReverb, this); // Right
	m_walls[2] = new Rect(std::string("Top Wall"), glm::vec3(0, m_reverbOuterRadius, 0),  glm::vec3(m_scale.x, m_scale.y, m_scale.z), m_rotation, m_cubeVertShader, m_cubeFragShader, m_wallOcclusion, m_wallReverb, this); // Top
	m_walls[3] = new Rect(std::string("Bottom Wall"), glm::vec3(0, -m_reverbOuterRadius, 0), glm::vec3(m_scale.x, m_scale.y, m_scale.z), m_rotation, m_cubeVertShader, m_cubeFragShader, m_wallOcclusion, m_wallReverb, this); // Back
	m_walls[4] = new Rect(std::string("Back Wall"), glm::vec3(0, 0, -m_reverbOuterRadius), glm::vec3(m_scale.x, m_scale.y, m_scale.z), m_rotation, m_cubeVertShader, m_cubeFragShader, m_wallOcclusion, m_wallReverb, this); // Bottom

	for (int i = 0; i < 5; ++i)
	{
		a_FMsystem->createGeometry(6, 24, &m_walls[i]->m_geometry);
		m_walls[i]->Init();
	}

	a_FMsystem->createChannelGroup("Music Channel Group", &m_audioGroup);

	m_sound = new SoundClass(&a_FMsystem, m_audioGroup, m_soundPosition, m_audioFilePath);
	m_sound->m_loop = true;
	m_sound->Play();
	FMOD_VECTOR pos = { m_position.x + m_sound->m_channelPosition.x, m_position.y + m_sound->m_channelPosition.y, m_position.z + m_sound->m_channelPosition.z };
	m_sound->m_channelPosition = pos;
	m_sound->m_channelRef->setVolume(20);

	m_reverb->set3DAttributes(&m_reverbPosition, 10, 20);
	m_reverb->setProperties(&m_reverbProps);
}

void OpenBox::Update(Camera* a_camera)
{
	Node::Update();
	//for (int i = 0; i < 5; i++)
	//{
	//	unsigned int projectionViewUniform = glGetUniformLocation(m_walls[i]->m_programID, "ProjectionView");
	//	glUniformMatrix4fv(projectionViewUniform, 1, false, glm::value_ptr(a_camera->view_proj));
	//
	//	unsigned int worldMatrix = glGetUniformLocation(m_walls[i]->m_programID, "WorldMatrix");
	//	glUniformMatrix4fv(worldMatrix, 1, false, glm::value_ptr(m_walls[i]->m_worldMatrix));
	//
	//	Gizmos::addAABB(m_walls[i]->m_position + m_position, m_walls[i]->m_scale * 0.5f, vec4(1,1,1,0), &m_walls[i]->m_worldMatrix);
	//}

	unsigned int projectionViewUniform = glGetUniformLocation(m_walls[0]->m_programID, "ProjectionView");
	glUniformMatrix4fv(projectionViewUniform, 1, false, glm::value_ptr(a_camera->view_proj));

	unsigned int worldMatrix = glGetUniformLocation(m_walls[0]->m_programID, "WorldMatrix");
	glUniformMatrix4fv(worldMatrix, 1, false, glm::value_ptr(m_walls[0]->m_worldMatrix));

	Gizmos::addAABB(m_walls[0]->m_position + m_position, m_walls[0]->m_scale * 0.5f, vec4(1, 1, 1, 0), &m_walls[0]->m_worldMatrix);

	projectionViewUniform = glGetUniformLocation(m_walls[1]->m_programID, "ProjectionView");
	glUniformMatrix4fv(projectionViewUniform, 1, false, glm::value_ptr(a_camera->view_proj));

	worldMatrix = glGetUniformLocation(m_walls[1]->m_programID, "WorldMatrix");
	glUniformMatrix4fv(worldMatrix, 1, false, glm::value_ptr(m_walls[1]->m_worldMatrix));

	Gizmos::addSphere(m_position, m_reverbOuterRadius, 10, 10, glm::vec4(0));
}

void OpenBox::Draw()
{
	m_walls[0]->DrawElements();
	m_walls[1]->DrawElements();
	m_walls[2]->DrawElements();
	m_walls[3]->DrawElements();
	m_walls[4]->DrawElements();
}
